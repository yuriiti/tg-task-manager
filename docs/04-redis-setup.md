# Redis Setup

## Обзор

Redis используется для кэширования данных, хранения сессий пользователей, rate limiting и опционально для pub/sub обновлений в реальном времени.

## Подключение

### Connection String

Формат строки подключения: `redis://host:port`

### NestJS конфигурация

Конфигурация Redis настраивается через @nestjs/config с использованием переменных окружения для host, port, password, db и TTL.


## Использование

### 1. Кэширование данных задач

**Кэш репозиторий:**

Реализует методы для работы с кэшем задач: получение задачи по ID, сохранение задачи с TTL, удаление задачи, получение списка задач пользователя, инвалидация кэша пользователя.

**Интерцептор для автоматического кэширования:**

Перехватывает HTTP запросы, проверяет наличие данных в кэше, возвращает кэшированные данные или выполняет запрос и сохраняет результат в кэш.

### 2. Сессии пользователей

**Сервис сессий:**

Реализует методы для управления сессиями: создание сессии с данными пользователя и TTL, получение сессии, удаление сессии, продление TTL сессии.

### 3. Rate Limiting

**Guard для rate limiting:**

Реализует ограничение количества запросов по IP адресу. Использует инкремент счетчика в Redis с установкой TTL при первом запросе. Блокирует запросы при превышении лимита.

### 4. Pub/Sub для real-time обновлений (опционально)

**Pub/Sub сервис:**

Использует дублированные Redis клиенты для publisher и subscriber. Реализует методы для публикации сообщений в каналы, подписки на каналы с callback обработчиками и отписки от каналов.


## Key Naming Conventions

Для организации ключей используется конвенция: `{prefix}:{entity}:{id}` или `{prefix}:{entity}:{filter}:{value}`. Это обеспечивает структурированное именование и упрощает управление ключами.

## TTL (Time To Live)

**Рекомендуемые значения TTL:**

- **Tasks**: 3600 секунд (1 час)
- **User tasks list**: 1800 секунд (30 минут)
- **Sessions**: 604800 секунд (7 дней)
- **Rate limit counters**: 60 секунд (1 минута)

## Мониторинг

### Проверка использования памяти

Используется команда `INFO memory` для получения информации об использовании памяти Redis.

### Просмотр и управление ключами

- `KEYS "*"` - просмотр всех ключей (осторожно на production)
- `--scan --pattern` - безопасное сканирование ключей по паттерну
- `FLUSHALL` - очистка всех ключей
- Удаление ключей по паттерну через комбинацию scan и del

## Оптимизация

### Использование Pipeline для множественных операций

Pipeline позволяет выполнять несколько команд Redis за один round-trip, что значительно ускоряет операции с множеством ключей.

### Использование Lua скриптов для атомарных операций

Lua скрипты выполняются атомарно на стороне Redis, что позволяет реализовать сложную логику без race conditions.

## Безопасность

1. **Пароль**: Всегда используйте пароль в production
2. **Firewall**: Ограничьте доступ к Redis только из приложения
3. **TLS**: Используйте TLS для соединений в production
4. **Команды**: Отключите опасные команды (FLUSHALL, CONFIG)

## Резервное копирование

Redis поддерживает RDB и AOF persistence:

- **RDB**: Снимки базы данных в определенные моменты времени
- **AOF**: Логирование всех операций записи

В docker-compose.yml уже настроен AOF через `--appendonly yes`.
